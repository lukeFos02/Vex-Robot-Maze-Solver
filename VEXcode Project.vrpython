{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\n\ndef main():\n    turns = 0\n    start_x = location.position(X, MM)\n    start_y = location.position(Y, MM)\n    locations = [[start_x, start_y]]\n    fastest_route = []\n    pen.set_pen_color(GREEN)\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    #Keep looping until robot is on the finish tile\n\n    while down_eye.detect(RED) == False:\n        wait(5, MSEC)\n        pen.move(DOWN)\n\n        #Checks if a wall is within the next tile infront of robot\n\n        if front_distance.get_distance(MM) > 260:\n\n            #Stops robot driving off the map\n            if location.position(X, MM) == start_x and location.position(Y, MM) == start_y and drivetrain.heading(DEGREES) == 180:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n\n            drivetrain.drive_for(FORWARD, 250, MM)\n\n            current_x = location.position(X, MM)\n            current_y = location.position(Y, MM)\n\n            #Have to round position to nearest 50 as sometimes the robot shifts a little while moving\n\n            current_x = 50 * round(current_x/50)\n            current_y = 50 * round(current_y/50)\n\n            #Removes positions from the array that lead to a dead end\n\n            for loc in locations:\n                if loc == [current_x, current_y]:\n                    index = locations.index([current_x, current_y])\n                    del locations[index:]\n                    break\n\n            locations.append([current_x, current_y])\n\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n    brain.print(locations)\n    brain.new_line()\n\n    del locations[0]\n\n    #Loops over the xy coordinates and translates it to directions moved\n\n    prev_x = start_x\n    prev_y = start_y\n    for loc in locations:\n        if prev_x > loc[0]:\n            fastest_route.append('Left')\n        if prev_x < loc[0]:\n            fastest_route.append('Right')\n        if prev_y > loc[1]:\n            fastest_route.append('Down')\n        if prev_y < loc[1]:\n            fastest_route.append('Up')\n        prev_x = loc[0]\n        prev_y = loc[1]\n    brain.print(fastest_route)\n    brain.new_line()\n\n    return_route = []\n\n    #Reverses directions to finish line so it creates a route to the start\n\n    for direction in reversed(fastest_route):\n        if direction == 'Left':\n            return_route.append('Right')\n        if direction == 'Right':\n            return_route.append('Left')\n        if direction == 'Up':\n            return_route.append('Down')\n        if direction == 'Down':\n            return_route.append('Up')\n\n    brain.print(return_route)\n    \n    #Makes robot return to the start tile\n\n    pen.set_pen_color(BLUE)\n    wait(5, MSEC)\n    for direction in return_route:\n        if direction == 'Left':\n            drivetrain.turn_to_heading(270, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n        if direction == 'Right':\n            drivetrain.turn_to_heading(90, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n        if direction == 'Up':\n            drivetrain.turn_to_heading(0, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n        if direction == 'Down':\n            drivetrain.turn_to_heading(180, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n    \n    maze_dictionary = []\n    prev_heading = 0\n    drivetrain.turn_to_heading(0, DEGREES)\n\n    #Starts mapping maze\n\n    while down_eye.detect(RED) == False:\n        wait(5, MSEC)\n        wall_left = 0\n        wall_right = 0\n        wall_up = 0\n        wall_down = 0\n        tile = ''\n\n        #Looks around current position and makes note of walls\n\n        drivetrain.turn_to_heading(0, DEGREES)\n        if front_distance.get_distance(MM) < 70:\n            wall_up = 1\n        drivetrain.turn_to_heading(90, DEGREES)\n        wait(5, MSEC)\n        if front_distance.get_distance(MM) < 70:\n            wall_right = 1\n        drivetrain.turn_to_heading(180, DEGREES)\n        wait(5, MSEC)\n        if front_distance.get_distance(MM) < 70:\n            wall_down = 1\n        drivetrain.turn_to_heading(270, DEGREES)\n        wait(5, MSEC)\n        if front_distance.get_distance(MM) < 70:\n            wall_left = 1\n        wait(5, MSEC)\n\n        #Makes a tile character based off walls\n\n        if wall_left == 1:\n            tile = '|' + tile\n        if wall_up == 1 and wall_down == 1:\n            tile = tile + '⁐'\n        if wall_up == 1 and wall_down == 0:\n            tile = tile + '⁀'\n        if wall_up == 0 and wall_down == 1:\n            tile = tile + '‿'\n        if wall_up == 0 and wall_down == 0:\n            tile = tile + ' '\n        if wall_right == 1:\n            tile = tile + '|'\n\n        brain.print(tile)\n        brain.new_line()\n\n        current_x = location.position(X, MM)\n        current_y = location.position(Y, MM)\n\n        current_x = 50 * round(current_x/50)\n        current_y = 50 * round(current_y/50)\n\n        maze_dictionary.append({'x': current_x, 'y': current_y, 'tile': tile})\n\n        drivetrain.turn_to_heading(prev_heading, DEGREES)\n\n        moved_tile = False\n        while moved_tile == False:\n            wait(5, MSEC)\n            if front_distance.get_distance(MM) > 260:\n                if location.position(X, MM) == (50 * round(start_x/50)) and location.position(Y, MM) == (50 * round(start_y/50)) and drivetrain.heading(DEGREES) == 180:\n                    drivetrain.turn_for(RIGHT, 90, DEGREES)\n                drivetrain.drive_for(FORWARD, 250, MM)\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n                prev_heading = drivetrain.heading(DEGREES)\n                moved_tile = True\n            else:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n                prev_heading = drivetrain.heading(DEGREES)\n        \n    #Grabs unique values\n\n    unique = []\n    for val in maze_dictionary:\n        if val not in unique:\n            unique.append(val)\n    \n    brain.print(unique)\n    brain.new_line()\n\n    #Prints of the maze to console\n\n    row1 = []\n    for val in unique:\n        if val['y'] == 850:\n            row1.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row1:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row2 = []\n    for val in unique:\n        if val['y'] == 600:\n            row2.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row2:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row3 = []\n    for val in unique:\n        if val['y'] == 350:\n            row3.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row3:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row4 = []\n    for val in unique:\n        if val['y'] == 100:\n            row4.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row4:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row5 = []\n    for val in unique:\n        if val['y'] == -150:\n            row5.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row5:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row6 = []\n    for val in unique:\n        if val['y'] == -400:\n            row6.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row6:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row7 = []\n    for val in unique:\n        if val['y'] == -650:\n            row7.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row7:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n    brain.new_line()\n    x = -850\n\n    row8 = []\n    for val in unique:\n        if val['y'] == -900:\n            row8.append(val)\n\n    x = -850\n    for i in range(8):\n        tile_found = False\n        for val in row8:\n            if val['x'] > x - 100 and val['x'] < x + 100:\n                brain.print(val['tile'])\n                tile_found = True\n        if tile_found == False:\n            brain.print('??')\n        x = x + 250\n\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}